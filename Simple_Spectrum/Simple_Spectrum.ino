#include <avr/pgmspace.h>
#define FHT_N 256
#define LIN_OUT 1
#include <FHT.h>
//#include <Adafruit_NeoPixel.h>

//
// Spectrum analyzer
// Pete Reiter
// Spectrum analyzer with a Adafruit neopixel strip as output. Unlike an ordinary 2-dimensional spectrum
// analyzer that uses Y-axis is display intensity of each frequency band, this uses color and brightness of
// the LEDs to indicate the intensity. This code was originally adapted from the PICCOLO tiny music visualizer
// on the Adafruit web site.
// 
// Software requirements:
// - FHT library for Arduino
// - Adafruit Neopixel library.

#define PIN 12 // digital pin for programming neopixels
#define PIXELS 144 // this is the size of my neopixel strip           

//Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_PIXELS, PIN, NEO_GRB + NEO_KHZ800);

// Microphone connects to Analog Pin 0.  Corresponding ADC channel number
// varies among boards...it's ADC0 on Uno and Mega, ADC7 on Leonardo.
// Other boards may require different settings; refer to datasheet.
#ifdef __AVR_ATmega32U4__
 #define ADC_CHANNEL 7
#else
 #define ADC_CHANNEL 0
#endif

volatile uint32_t samplePos = 0;     // Buffer position counter

static const uint8_t PROGMEM
  // This is low-level noise that's subtracted from each FHT output column
  // This was experimentally determined in a quiet room.
  noise[128]={ 
    50, 12, 10, 8, 7, 6, 6, 5, // 0
    5, 5, 4, 4, 4, 4, 4, 4,    // 8
    4, 4, 4, 4, 4, 4, 4, 4,    // 16
    4, 4, 4, 4, 4, 4, 4, 4,    // 24
    4, 4, 4, 4, 4, 4, 4, 4,    // 32
    3, 3, 3, 4, 3, 3, 3, 3,    // 40
    3, 3, 3, 3, 3, 3, 3, 3,    // 48    
    3, 3, 3, 3, 3, 3, 3, 3,    // 56
    3, 3, 3, 3, 3, 3, 3, 3,    // 64
    3, 3, 3, 3, 3, 3, 3, 3,    // 72
    3, 3, 3, 3, 3, 3, 3, 3,    // 80
    3, 3, 3, 3, 3, 3, 3, 3,    // 88
    3, 3, 3, 3, 3, 3, 3, 3,    // 96
    3, 3, 3, 3, 3, 3, 3, 3,    // 104
    3, 3, 3, 3, 3, 3, 3, 3,    // 112
    3, 3, 3, 3, 3, 3, 3, 3     // 120
};

static const uint8_t PROGMEM
  calibration[128] = {
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3  
  } ;
  
static const byte  PROGMEM slots[160] =
  // combine the 128 FFT frequency output slots into buckets based on octaves.
  // for the lower frequencies multiple leds display a single frequency slot.
  // for the higher frequencies multiple frequency slots are combined into a aingle led 
   {
    1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 
    9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15,
   16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31,
   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
   65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127
   };

// This is the mapping from the values in the buckets to the colors representing those values. These numbers were generated by some C code that I've pasted into the bottom of this
// file. The colors go from blue->green->red with an increase in intensity as the values increase. There's also a log10 based response curve figured in.
#define NUM_COLORS 64
static const uint32_t PROGMEM colors[NUM_COLORS] = { 
0x42, 0x1c37, 0x332e, 0x4823, 0x5b1a, 0x6c11, 0x7c08, 0x8c00, 0x88900, 0x108600, 0x178300, 0x1e8100, 0x267e00, 0x2d7b00, 0x347700, 0x3a7400, 0x407100, 0x466e00, 0x4d6b00, 0x526800, 0x586500, 0x5e6200, 0x636000, 0x685d00, 0x6d5a00, 0x725700, 0x775400, 0x7c5100, 0x804f00, 0x864c00, 0x8a4900, 0x8f4600, 0x924400, 0x974100, 0x9b3f00, 0x9f3c00, 0xa33a00, 0xa83700, 0xab3500, 0xaf3200, 0xb33000, 0xb72e00, 0xbb2b00, 0xbe2900, 0xc12700, 0xc52400, 0xc92200, 0xcc2000, 0xd01e00, 0xd31c00, 0xd71900, 0xda1700, 0xdc1500, 0xe01300, 0xe31100, 0xe60f00, 0xe90d00, 0xec0b00, 0xf00800, 0xf30600, 0xf60400, 0xf90200, 0xfc0000, 0xff0000
}; 

#define THRESHOLD 1
// The prescaler settings determine the frequency of audio sampling. We can sample higher
// frequencies with a lower prescaler value, but it will also raise the lowest frequency that
// we can sample. With this setup, I seem to be getting around 300Hz-9.6KHz response. There is
// some aliasing going on, meaning that frequencies > 9.6KHz will show up in lower frequency
// response.



/*
 This is an example of how simple driving a Neopixel can be
 This code is optimized for understandability and changability rather than raw speed
 More info at http://wp.josh.com/2014/05/11/ws2812-neopixels-made-easy/
*/

// Change this to be at least as long as your pixel string (too long will work fine, just be a little slower)

#define PIXELS 600  // Number of pixels in the string

// These values depend on which pin your string is connected to and what board you are using 
// More info on how to find these at http://www.arduino.cc/en/Reference/PortManipulation

// These values are for the pin that connects to the Data Input pin on the LED strip. They correspond to...

// Arduino Yun:     Digital Pin 8
// DueMilinove/UNO: Digital Pin 12
// Arduino MeagL    PWM Pin 4

// You'll need to look up the port/bit combination for other boards. 

// Note that you could also include the DigitalWriteFast header file to not need to to this lookup.

#define PIXEL_PORT  PORTB  // Port of the pin the pixels are connected to
#define PIXEL_DDR   DDRB// Port of the pin the pixels are connected to
#define PIXEL_BIT   4      // Bit of the pin the pixels are connected to

// These are the timing constraints taken mostly from the WS2812 datasheets 
// These are chosen to be conservative and avoid problems rather than for maximum throughput 

#define T1H  900    // Width of a 1 bit in ns
#define T1L  600    // Width of a 1 bit in ns

#define T0H  400    // Width of a 0 bit in ns
#define T0L  900    // Width of a 0 bit in ns

#define RES 6000    // Width of the low gap between bits to cause a frame to latch

// Here are some convience defines for using nanoseconds specs to generate actual CPU delays

#define NS_PER_SEC (1000000000L)          // Note that this has to be SIGNED since we want to be able to check for negative values of derivatives

#define CYCLES_PER_SEC (F_CPU)

#define NS_PER_CYCLE ( NS_PER_SEC / CYCLES_PER_SEC )

#define NS_TO_CYCLES(n) ( (n) / NS_PER_CYCLE )

// Actually send a bit to the string. We must to drop to asm to enusre that the complier does
// not reorder things and make it so the delay happens in the wrong place.

inline void sendBit( bool bitVal ) {
  
    if (  bitVal ) {        // 0 bit
      
    asm volatile (
      "sbi %[port], %[bit] \n\t"        // Set the output bit
      ".rept %[onCycles] \n\t"                                // Execute NOPs to delay exactly the specified number of cycles
      "nop \n\t"
      ".endr \n\t"
      "cbi %[port], %[bit] \n\t"                              // Clear the output bit
      ".rept %[offCycles] \n\t"                               // Execute NOPs to delay exactly the specified number of cycles
      "nop \n\t"
      ".endr \n\t"
      ::
      [port]    "I" (_SFR_IO_ADDR(PIXEL_PORT)),
      [bit]   "I" (PIXEL_BIT),
      [onCycles]  "I" (NS_TO_CYCLES(T1H) - 2),    // 1-bit width less overhead  for the actual bit setting, note that this delay could be longer and everything would still work
      [offCycles]   "I" (NS_TO_CYCLES(T1L) - 2)     // Minimum interbit delay. Note that we probably don't need this at all since the loop overhead will be enough, but here for correctness

    );
                                  
    } else {          // 1 bit

    // **************************************************************************
    // This line is really the only tight goldilocks timing in the whole program!
    // **************************************************************************


    asm volatile (
      "sbi %[port], %[bit] \n\t"        // Set the output bit
      ".rept %[onCycles] \n\t"        // Now timing actually matters. The 0-bit must be long enough to be detected but not too long or it will be a 1-bit
      "nop \n\t"                                              // Execute NOPs to delay exactly the specified number of cycles
      ".endr \n\t"
      "cbi %[port], %[bit] \n\t"                              // Clear the output bit
      ".rept %[offCycles] \n\t"                               // Execute NOPs to delay exactly the specified number of cycles
      "nop \n\t"
      ".endr \n\t"
      ::
      [port]    "I" (_SFR_IO_ADDR(PIXEL_PORT)),
      [bit]   "I" (PIXEL_BIT),
      [onCycles]  "I" (NS_TO_CYCLES(T0H) - 2),
      [offCycles] "I" (NS_TO_CYCLES(T0L) - 2)

    );
      
    }
    
    // Note that the inter-bit gap can be as long as you want as long as it doesn't exceed the 5us reset timeout (which is A long time)
    // Here I have been generous and not tried to squeeze the gap tight but instead erred on the side of lots of extra time.
    // This has thenice side effect of avoid glitches on very long strings becuase 

    
}  

  
inline void sendByte( unsigned char byte ) {
    
    for( unsigned char bit = 0 ; bit < 8 ; bit++ ) {
      
      sendBit( bitRead( byte , 7 ) );                // Neopixel wants bit in highest-to-lowest order
                                                     // so send highest bit (bit #7 in an 8-bit byte since they start at 0)
      byte <<= 1;                                    // and then shift left so bit 6 moves into 7, 5 moves into 6, etc
      
    }           
} 

/*

  The following three functions are the public API:
  
  ledSetup() - set up the pin that is connected to the string. Call once at the begining of the program.  
  sendPixel( r g , b ) - send a single pixel to the string. Call this once for each pixel in a frame.
  show() - show the recently sent pixel on the LEDs . Call once per frame. 
  
*/


// Set the specified pin up as digital out

void ledsetup() {
  
  bitSet( PIXEL_DDR , PIXEL_BIT );
  
}

inline void sendPixel( unsigned char r, unsigned char g , unsigned char b )  {  
  
  sendByte(g);          // Neopixel wants colors in green then red then blue order
  sendByte(r);
  sendByte(b);
  
}


// Just wait long enough without sending any bots to cause the pixels to latch and display the last sent frame

void show() {
  _delay_us( (RES / 1000UL) + 1);       // Round up since the delay must be _at_least_ this long (too short might not work, too long not a problem)
}


/*

  That is the whole API. What follows are some demo functions rewriten from the AdaFruit strandtest code...
  
  https://github.com/adafruit/Adafruit_NeoPixel/blob/master/examples/strandtest/strandtest.ino
  
  Note that we always turn off interrupts while we are sending pixels becuase an interupt
  could happen just when we were in the middle of somehting time sensitive.
  
  If we wanted to minimize the time interrupts were off, we could instead 
  could get away with only turning off interrupts just for the very brief moment 
  when we are actually sending a 0 bit (~1us), as long as we were sure that the total time 
  taken by any interrupts + the time in our pixel generation code never exceeded the reset time (5us).
  
*/


// Display a single color on the whole string

void showColor( unsigned char r , unsigned char g , unsigned char b ) {
  
  cli();  
  for( int p=0; p<PIXELS; p++ ) {
    sendPixel( r , g , b );
  }
  sei();
  show();
  
}

// Fill the dots one after the other with a color
// rewrite to lift the compare out of the loop
void colorWipe(unsigned char r , unsigned char g, unsigned char b, unsigned  char wait ) {
  for(unsigned int i=0; i<PIXELS; i+= (PIXELS/60) ) {
    
    cli();
    unsigned int p=0;
    
    while (p++<=i) {
        sendPixel(r,g,b);
    } 
     
    while (p++<=PIXELS) {
        sendPixel(0,0,0);  
      
    }
    
    sei();
    show();
    delay(wait);
  }
}

// Theatre-style crawling lights.
// Changes spacing to be dynmaic based on string size

#define THEATER_SPACING (PIXELS/20)

void theaterChase( unsigned char r , unsigned char g, unsigned char b, unsigned char wait ) {
  
  for (int j=0; j< 3 ; j++) {  
  
    for (int q=0; q < THEATER_SPACING ; q++) {
      
      unsigned int step=0;
      
      cli();
      
      for (int i=0; i < PIXELS ; i++) {
        
        if (step==q) {
          
          sendPixel( r , g , b );
          
        } else {
          
          sendPixel( 0 , 0 , 0 );
          
        }
        
        step++;
        
        if (step==THEATER_SPACING) step =0;
        
      }
      
      sei();
      
      show();
      delay(wait);
      
    }
    
  }
  
}
        


// I rewrite this one from scrtach to use high resolution for the color wheel to look nicer on a *much* bigger string
                                                                            
void rainbowCycle(unsigned char frames , unsigned int frameAdvance, unsigned int pixelAdvance ) {
  
  // Hue is a number between 0 and 3*256 than defines a mix of r->g->b where
  // hue of 0 = Full red
  // hue of 128 = 1/2 red and 1/2 green
  // hue of 256 = Full Green
  // hue of 384 = 1/2 green and 1/2 blue
  // ...
  
  unsigned int firstPixelHue = 0;     // Color for the first pixel in the string
  
  for(unsigned int j=0; j<frames; j++) {                                  
    
    unsigned int currentPixelHue = firstPixelHue;
       
    cli();    
        
    for(unsigned int i=0; i< PIXELS; i++) {
      
      if (currentPixelHue>=(3*256)) {                  // Normalize back down incase we incremented and overflowed
        currentPixelHue -= (3*256);
      }
            
      unsigned char phase = currentPixelHue >> 8;
      unsigned char step = currentPixelHue & 0xff;
                 
      switch (phase) {
        
        case 0: 
          sendPixel( ~step , step ,  0 );
          break;
          
        case 1: 
          sendPixel( 0 , ~step , step );
          break;

        case 2: 
          sendPixel(  step ,0 , ~step );
          break;
          
      }
      
      currentPixelHue+=pixelAdvance;                                      
      
                          
    } 
    
    sei();
    
    show();
    
    firstPixelHue += frameAdvance;
           
  }
}

  
// I added this one just to demonstrate how quickly you can flash the string.
// Flashes get faster and faster until *boom* and fade to black.

void detonate( unsigned char r , unsigned char g , unsigned char b , unsigned int startdelayms) {
  while (startdelayms) {
    
    showColor( r , g , b );      // Flash the color 
    showColor( 0 , 0 , 0 );
    
    delay( startdelayms );      
    
    startdelayms =  ( startdelayms * 4 ) / 5 ;           // delay between flashes is halved each time until zero
    
  }
  
  // Then we fade to black....
  
  for( int fade=256; fade>0; fade-- ) {
    
    showColor( (r * fade) / 256 ,(g*fade) /256 , (b*fade)/256 );
        
  }
  
  showColor( 0 , 0 , 0 );
  
    
}







void setup() {
  // Init ADC free-run mode; f = ( 16MHz/prescaler ) / 13 cycles/conversion 
  ADMUX  = ADC_CHANNEL; // Channel sel, right-adj, use AREF pin
  ADCSRA = _BV(ADEN)  | // ADC enable
           _BV(ADSC)  | // ADC start
           _BV(ADATE) | // Auto trigger
           _BV(ADIE)  | // Interrupt enable
           // select the prescaler value. Note that the max frequency our FFT will
           // display is half the sample rate.
//           _BV(ADPS2) | _BV(ADPS0); // 32:1 / 13 = 38,460 Hz
           _BV(ADPS2) | _BV(ADPS1); // 64:1 / 13 = 19,230 Hz
//           _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0); // 128:1 / 13 = 9615 Hz
  ADCSRB = 0;                // Free run mode, no high MUX bit
  DIDR0  = 1 << ADC_CHANNEL; // Turn off digital input for ADC pin
  TIMSK0 = 0;                // Timer0 off

  // Neopixels setup
  // Initialize all pixels to 'off'
//  strip.setBrightness(255);
//  strip.begin(); // Initialize all pixels to 'off'
//  cli();         // disable interrupts when writing neopixels   
//  strip.show();
//  sei();         // Enable interrupts
//  Serial.begin(9600);  // set up Serial library at 9600 bps for debugging purposes
  
  ledsetup();
}


void loop() {
  uint16_t  x, L;
  while(ADCSRA & _BV(ADIE)); // Wait for audio sampling to finish

  fht_window();
  fht_reorder();
  fht_run();
  fht_mag_lin();
  samplePos = 0;                   // Reset sample counter
  ADCSRA |= _BV(ADIE);             // Resume sampling interrupt
  
  // Remove noise
  for(x=0; x<FHT_N/2; x++) {
//    L = (pgm_read_byte(&noise[x]) << 6);
//    fht_lin_out[x] = (fht_lin_out[x] <= L) ? 0 : (fht_lin_out[x] - L);
  }
//  for(int i = 0;i < 5;i++){
//    Serial.print(fht_lin_out[i]);
//    Serial.print(", ");
//  }
//  Serial.println();
  
  fht_lin_out[1] = (fht_lin_out[1] <= 500) ? 0 : (fht_lin_out[1] - 400);

  showColor(0,0,5);
//   Combine the frequency output slots into a smaller number of output
//   buckets
  first_try();
  delay(100);
  show();
  delay(10);

  int sp = 0;
  if(sp == 1){
    int previous = -1, current = -1, next = -1;
    for (int i = 0; i < PIXELS; i++){
        int value = 0;
        previous = current;
        current = (next == -1) ? pgm_read_byte(&slots[i]) : next;
        next = pgm_read_byte(&slots[i+1]);
        if ((next - current) > 2)
        { // this led combines the results of multiple frequency slots
          for (int j = current; j < next; j++)
            value += fht_lin_out[j];
        }
        // if we have one slot going to multiple leds, do some averaging on the boundary so that the transition isn't so abrupt
        else if (current == previous && current != next)
          value = (fht_lin_out[current] + fht_lin_out[next])/2;
        else // just use the value
          value = fht_lin_out[current];
  
        value >>= 6;
        if (value < 6)
          value = 0;
          //showColor(0,0,5);
        if (value >= NUM_COLORS)
          value = NUM_COLORS - 1;
          //showColor(50,0,0); 
          //delay(100); 
//        strip.setPixelColor(i, pgm_read_dword(&colors[value]));
    }
    //cli();        // no interrupts while writing the neopixels
    //show();
    //sei();        // restore interrupts
  }
}


void first_try(){
  int base_line = 1;
  int base_led = 60;
    float led_nums = 0;
    for(int f = 2; (f < FHT_N/2)/3; f++){ //third of bins from red to green
      int bin = fht_lin_out[f];
      //int bin = fht_lin_out[f];
      if(bin>base_line){
        led_nums = bin/5;
        if(led_nums > 30){
          led_nums = 30;
        }
        if(led_nums < 2){
          led_nums = 0;
        }
        for(int i=0+(18*f); i<led_nums+(18*f); i++) {
  //        base_strip.setPixelColor(i,255-(16*f),16*f,0);
          sendPixel(255-(16*f),16*f,0);
  
  //        sendPixel(r,g,b)
      }
    }
  }
}

// interrupt service routine. This gets called each time the ADC finishes 1 sample.
ISR(ADC_vect) { // Audio-sampling interrupt
  // shift the unsigned input to be centered around 0. The 10-bit ADC is 
  // capable of producing values from 0 - 1023, but with a microphone that outputs
  // 2V max and a reference voltage of 3.3V we will never hit the max.
  fht_input[samplePos] = (ADC - 512) << 6;
//  Serial.println(fht_input[samplePos]);
  if(++samplePos >= FHT_N) ADCSRA &= ~_BV(ADIE); // Buffer full, interrupt off
}

//
// Some C code I used to generate the values->colors map. I didn't run this code on the Arduino. I used ideone.com
// and then pasted the output into my arduino code.
#if 0
#include <iostream>
#include <stdint.h>
#include <math.h>
using namespace std;


  
const int numValues = 64; // number of colors in our output array. This should correspond 
                          // to the max value you want to display.
double breakPoint = log10(numValues)/2.0;

//
// Blend two colors together based on the ratio. ratio of 0.0 will be 100% color a and
// ratio of 1.0 will be 100% color b.
uint32_t blend (uint32_t ina, uint32_t inb, double ratio)
{
  int r = (((ina >> 16) & 0xff) * (1.0-ratio)) + (((inb >> 16) & 0xff) * ratio);
  int g = (((ina >> 8) & 0xff) * (1.0-ratio)) + (((inb >> 8) & 0xff) * ratio);
  int b = (((ina >> 0) & 0xff) * (1.0-ratio)) + (((inb >> 0) & 0xff) * ratio);
  return ((r << 16) | (g << 8) | b);
}

//
// Scale the intensity of the passed in color. I am using max brightness colors and 
// 0.0 - 1.0 as the scale value.
uint32_t scale (uint32_t ina, double scale_value)
{
  int r = ((ina >> 16) & 0xff) * scale_value;
  int g = ((ina >> 8) & 0xff) * scale_value;
  int b = ((ina >> 0) & 0xff) * scale_value;
  return ((r << 16) | (g << 8) | b);  
}

//  
// Fade blue -> green -> red. I've built in a logarithmic response to make it more of a
// dB meter.
int main() { 
  for (int i = 1; i <= numValues; i++)
  {
    double logValue = log10(i);
    double scaleValue = log10(i+2) / log10(numValues+2);
    double ratio = (logValue < breakPoint) ? logValue / breakPoint : (logValue - breakPoint) / breakPoint;
    uint32_t color = 0;

    if (logValue < breakPoint)
      color = blend (0x0000ff, 0x00ff00, ratio);
    else
      color = blend (0x00ff00, 0xff0000, ratio);
    color = scale (color, scaleValue);
    cout <<  "0x" << hex << color << ", ";
  }
  return 0; 
}
#endif

